package avrohugger

import avrohugger.format.DependencyInspectionSupport._
import avrohugger.format._
import avrohugger.input._
import avrohugger.input.NestedSchemaExtractor._
import avrohugger.input.schemagen._
import avrohugger.input.parsers._


import java.io.{File, FileNotFoundException, IOException}

import org.apache.avro.Schema

import scala.collection.JavaConverters._

// Unable to overload the methods of this class because outDir uses a default value
class Generator(format: SourceFormat) {
  val sourceFormat = format
  val defaultOutputDir = "target/generated-sources"
  lazy val fileParser = new FileInputParser
  lazy val stringParser = new StringInputParser
  lazy val schemaParser = new Schema.Parser
  val classStore = new ClassStore

  // #### methods for writing definitions out to file ####
  def schemaToFile(schema: Schema, outDir: String = defaultOutputDir): Unit = {
    val namespace: Option[String] = getReferredNamespace(schema)
    val topLevelSchemas: List[Schema] = schema::(getNestedSchemas(schema))
    topLevelSchemas.reverse.foreach { schema => // most-nested classes processed first
      // pass in the top-level schema's namespace if the nested schema has none
      val ns = getReferredNamespace(schema) orElse namespace
      sourceFormat.writeToFile(classStore, ns, schema, outDir)
      SchemaStore.schemas.clear
    }
  }

  def stringToFile(schemaStr: String, outDir: String = defaultOutputDir): Unit = {
    val schemas = stringParser.getSchemas(schemaStr)
    schemas.foreach(schema => schemaToFile(schema, outDir))
  }

  def fileToFile(inFile: File, outDir: String = defaultOutputDir): Unit = {
    val schemas: List[Schema] = fileParser.getSchemas(inFile)
    schemas.foreach(schema => schemaToFile(schema, outDir))
  }



  // #### methods for writing definitions to a list of definitions in String format ####
  def schemaToStrings(schema: Schema): List[String] = {
    val namespace: Option[String] = getReferredNamespace(schema)
    val topLevelSchemas: List[Schema] = getNestedSchemas(schema)
    topLevelSchemas.reverse.map(schema => { //reversed to process nested classes first
      // pass in the top-level schema's namespace if the nested schema has none
      val ns = getReferredNamespace(schema) orElse namespace
      val codeString = sourceFormat.asDefinitionString(classStore, ns, schema)

      // drop the comments because it's not applicable outside of file writing/overwriting
      codeString
        .replace("/** MACHINE-GENERATED FROM AVRO SCHEMA. DO NOT EDIT DIRECTLY */\n", "")
        .replace("""/**
          | * Autogenerated by Avro
          | * 
          | * DO NOT EDIT DIRECTLY
          | */
          |""".stripMargin, "")
    }) 
  }

  def stringToStrings(schemaStr: String): List[String] = {
    val schemas = stringParser.getSchemas(schemaStr)
    // reverse to restore printing order after processing, top-level classes first 
    val codeStrings = schemas.flatMap(schema => schemaToStrings(schema)).reverse
    //reset the schema store after processing the whole submission
    SchemaStore.schemas.clear
    codeStrings
  }

  def fileToStrings(inFile: File): List[String] = {
    try {
      val schemas: List[Schema] = fileParser.getSchemas(inFile)
      schemas.flatMap(schema => schemaToStrings(schema))
    } 
    catch {
      case ex: FileNotFoundException => sys.error("File not found:" + ex)
      case ex: IOException => sys.error("There was a problem using the file: " + ex)
    }
  }

}

