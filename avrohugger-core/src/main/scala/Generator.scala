package avrohugger

import avrohugger.format._
import avrohugger.input.DependencyInspector._
import avrohugger.input.NestedSchemaExtractor._
import avrohugger.input.reflectivecompilation.schemagen._
import avrohugger.input.parsers._

import java.io.{File, FileNotFoundException, IOException}

import org.apache.avro.Schema

import scala.collection.JavaConverters._

// Unable to overload the methods of this class because outDir uses a default value
class Generator(format: SourceFormat,
  avroScalaCustomTypes: Map[String, Class[_]] = Map.empty,
  avroScalaCustomNamespace: Map[String, String] = Map.empty) {
    
  val sourceFormat = format
  val defaultOutputDir = "target/generated-sources"
  lazy val fileParser = new FileInputParser
  lazy val stringParser = new StringInputParser
  lazy val schemaParser = new Schema.Parser
  val classStore = new ClassStore
  val schemaStore = new SchemaStore
  //val typecheckDependencyStore = new 
  val typeMatcher = sourceFormat.typeMatcher
  avroScalaCustomTypes.foreach(typeMatcher.updateTypeMap)
  avroScalaCustomNamespace.foreach(typeMatcher.updateNamespaceMap)


  // #### methods for writing definitions out to file ####
  def schemaToFile(
    schema: Schema,
    outDir: String = defaultOutputDir): Unit = {

    val topLevelNamespace: Option[String] = getReferredNamespace(schema)
    val topLevelSchemas: List[Schema] = getNestedSchemas(schema, schemaStore)
    // most-nested classes processed first
    topLevelSchemas.reverse.distinct.foreach { schema =>
      // pass in the top-level schema's namespace if the nested schema has none
      val ns = getReferredNamespace(schema) orElse topLevelNamespace
      sourceFormat.writeToFile(classStore, ns, schema, outDir, schemaStore)
    }
  }

  def stringToFile(
    schemaStr: String,
    outDir: String = defaultOutputDir): Unit = {
    val schemas = stringParser.getSchemas(schemaStr, schemaStore)
    schemas.foreach(schema => schemaToFile(schema, outDir))
  }

  def fileToFile(
    inFile: File,
    outDir: String = defaultOutputDir): Unit = {
    val schemas: List[Schema] = fileParser.getSchemas(inFile)
    schemas.foreach(schema => schemaToFile(schema, outDir))
  }


  // #### methods for writing definitions to a list of definitions in String format ####
  def schemaToStrings(schema: Schema): List[String] = {
    val namespace: Option[String] = getReferredNamespace(schema)
    val topLevelSchemas: List[Schema] = getNestedSchemas(schema, schemaStore)
    //reversed to process nested classes first
    topLevelSchemas.reverse.distinct.map(schema => {
      // pass in the top-level schema's namespace if the nested schema has none
      val ns = getReferredNamespace(schema) orElse namespace
      val codeString = sourceFormat.asDefinitionString(classStore, ns, schema, schemaStore)
      // drop the comments because it's not applicable outside of file writing/overwriting
      filterWarningComment(codeString)
    })
  }

  def stringToStrings(schemaStr: String): List[String] = {
    val schemas = stringParser.getSchemas(schemaStr, schemaStore)
    // reverse to restore printing order after processing, top-level classes first
    val codeStrings = schemas.flatMap(schema => schemaToStrings(schema)).reverse.distinct
    //reset the schema store after processing the whole submission
    schemaStore.schemas.clear
    codeStrings
  }

  def fileToStrings(inFile: File): List[String] = {
    try {
      val schemas: List[Schema] = fileParser.getSchemas(inFile)
      schemas.flatMap(schema => schemaToStrings(schema))
    }
    catch {
      case ex: FileNotFoundException => sys.error("File not found:" + ex)
      case ex: IOException => sys.error("There was a problem using the file: " + ex)
    }
  }


  // #### utililty methods ####
  def filterWarningComment(codeStr: String): String = {
    codeStr
      .replace("/** MACHINE-GENERATED FROM AVRO SCHEMA. DO NOT EDIT DIRECTLY */\n", "")
      .replace("""/**
        | * Autogenerated by Avro
        | *
        | * DO NOT EDIT DIRECTLY
        | */
        |""".stripMargin, "")
  }


}
